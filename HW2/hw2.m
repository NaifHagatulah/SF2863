
close all; 
%% First we generate input data
birthdate = 19990301;  % Write the birth date on format yyyymmdd for oldest member in the group
format compact;
[lambdavec,Tvec,cvec] = getSPOdata(birthdate);   %yyyymmdd  Do not use clear command or change the values of these variables

% -------------------------------------------------------------------------------------------------------------------
%% Marginal Allocation
% Question 1 should be answered in the report

% Question 2 should described in the report, and submitted below
% Enter on the format EBO2 = [EBO_1(2) EBO_2(2) ... EBO_9(2)]      
% EBO_j(2) should be the EBO for two spares of LRU2
% Cost2 should be the total cost for the allocation of spares (scalar)
smax = 2;
cost = 0;
EBO2 = [];
for i=1:length(lambdavec)
    [p,R,EBO] = EBOcomp(lambdavec(i),Tvec(i), smax);
    EBO2 = [EBO2 EBO(smax+1)];
    cost = cost + costcomp(cvec(i),smax);
end 

Cost2 = cost;

Q2 = [EBO2 Cost2]; % Checking both at the same time in grader.

% Question 3, you should describe how the Marginal allocation is
% implemented in your own words in the report, and compute all efficient
% points.
%Step 0
it = 10;
k = 1;
nmrParts = size(lambdavec,2);
s = zeros(it,nmrParts);
C = zeros(it,1);
table = zeros(it, nmrParts);
tabletest = zeros(it, nmrParts);
for i=1:length(lambdavec)
    table(:,i) = Rcomp(lambdavec(i),Tvec(i),it)/cvec(i);
end
tabletest = table;
%generate EBO 0
EBO0 = lambdavec.*Tvec;

%Step 1 & 2
budget = 900;
spent = 0;
%svec = zeros(1, 9);
x = zeros(1,nmrParts);
X = x;
efficent_cost(1) = 0;
efficent_EBO(1) = sum(EBO0);

while budget > spent
    [r,c] = indexMax(table);
    spent = spent + cvec(c);
    if spent > budget
        break;
    end
    k = k+1;
    s(k,:) = s(k-1,:);
    s(k,c) = s(k-1,c) + 1;
    EBO0(c) = EBO0(c) - table(r,c) * cvec(c);
    if(EBO0(c) < 0)
        EBO0(c) = 0;
    end
    x(c) = x(c) + 1;
    X = [X; x];
    efficent_cost(k) = spent;
    efficent_EBO(k) = sum(EBO0);
    table(r,c) = 0;
end
%{
for i = 1:5
    [r,c] = indexMax(table);
    k = k+1;
    s(k,:) = s(k-1,:);
    s(k,c) = s(k-1,c) + 1;
    spent = spent + cvec(c);
    EBO0 = EBO0 - table(r,c) * cvec(c);
    x(c) = x(c) + 1;
    X(k-1, :) = x;
    efficent_cost(k - 1) = spent;
    efficent_EBO(k - 1) = EBO0;
    if(EBO0 < 0)
        efficent_EBO(k - 1) = 0;
    end
    table(r,c) = 0;
end
%}
%PLOT THE EFFICENT POINTS

figure
hold on;
plot(efficent_cost,efficent_EBO,'.-k','LineWidth',2,'MarkerSize',20)
plot(Cost2, sum(EBO2), 'ro', 'MarkerSize', 5)
legend('Efficient Points', '2 spare parts')
xlabel("Total Cost ",'FontSize',10,'interpreter','latex')
ylabel("EBO",'FontSize',10,'interpreter','latex')









% Question 4 should be answered in the report, with a figure and a table with
% all efficient points
% Furthermore, a table with first five efficient points should be submitted below
 
% Enter on the format EPtable = [ x0 EBO(x0) C(x0); x1 EB0(x1) C(x1); ... x4 EBO(x4) C(x4)]
% Where xj is the row vector with number of spare parts of each kind
% corresponding to the efficient points generated by the Marginal allocation algorithm
% EBO and C are the total values (scalars) for each allocation xj
EPcalc = zeros(5,11);
for i=1:k
    EPcalc(i,:) = [X(i,:), efficent_EBO(i), efficent_cost(i)];
end
EPtable = EPcalc(1:5,:);


% Question 5 should be discussed in the report

% You may use the commands below as a template to plot the figures.
% fig1 = figure(1)
% plot(total_cost,EBO_expect,'.-k','LineWidth',2,'MarkerSize',20)
% hold on   % Keeps old plots and adds new plots on top of the old
% hold off  % Replaces old plots with the new one
% grid on
% set(gca,'FontSize',20,'TickLabelInterpreter','latex')
% xlabel("Total Cost [-]",'FontSize',20,'interpreter','latex')
% ylabel("EBO [-]",'FontSize',20,'interpreter','latex')
% title('Efficient Solutions Curve','FontSize',20,'interpreter','latex')
% print(fig1, '-dpdf', 'myfigure.pdf'); % save to the 'myfigure.pdf' file

% -------------------------------------------------------------------------------------------------------------------
%% Dynamic Programming
% Question 6 should be answered in the report

% Question 7 should be answered in the report, and submitted below
% as a row vector with numbers of LRU1 used for budget 0 to 50.


%create loop that iterates over the budget untill we cannot pick a new part
s0 = zeros(1, nmrParts);
%create a new function that gives EBO for a given S vector
EBO0 = EBO_calc(s0,lambdavec, Tvec);
budget = 500;
spent = 0;
first_optimal = EBO_calc(s0,lambdavec, Tvec) 
while true
    EBO_optimal_old = 1000000;
    for i = 1:nmrParts
        X = zeros(1, nmrParts);
        X(i) = 1;
        EBO_optimal_new = EBO_calc(s0 + X, lambdavec, Tvec);
        disp("s "+ num2str(s0+X) + " it " + i + " EBO " + EBO_optimal_new)
        if EBO_optimal_new < EBO_optimal_old && (s0 * cvec' + X * cvec') <= budget
            EBO_optimal_old = EBO_optimal_new;
            X_optimal = X;
            spent = s0 * cvec' + X * cvec';
        end
    end
    if EBO_optimal_old == 1000000
        break;
    end
   s0 = s0 + X_optimal; 
end



% Initialize the spare parts vector
s0 = zeros(1, nmrParts);

% Calculate the initial EBO for the starting state
EBO0 = EBO_calc(s0, lambdavec, Tvec);

% Define the total budget
budget = 500;
spent = 0;

% Display the initial EBO value
disp(['Initial EBO: ', num2str(EBO0)]);

while true
    % Initialize variables for tracking the best improvement
    best_EBO = inf;  % Use `inf` for clarity and to handle floating-point values
    X_optimal = zeros(1, nmrParts);  % Placeholder for the best part addition

    % Loop over all possible parts to add
    for i = 1:nmrParts 
        X = zeros(1, nmrParts);
        X(i) = 1;

         % Check if adding this part respects the budget
        if (s0 * cvec' + X * cvec') <= budget
            % Calculate the EBO for the new state
            EBO_new = EBO_calc(s0 + X, lambdavec, Tvec);

            % Check if this addition yields the best EBO so far
            if EBO_new < best_EBO
                best_EBO = EBO_new;
                X_optimal = X;  % Update the best choice
            end
        end
    end

    % Check if no improvement is possible
    if best_EBO == inf
        break;  % Exit the loop if no part addition improves the solution
    end

    % Update the state and spent budget
    s0 = s0 + X_optimal;
    spent = s0 * cvec';  % Update the total spent budget

    % Display the current state and EBO
    disp(['Updated s0: ', mat2str(s0)]);
    disp(['Current EBO: ', num2str(best_EBO)]);
    disp(['Budget Spent: ', num2str(spent)]);
end

% Final output
disp('Final optimal spare parts allocation:');
disp(s0);
disp(['Final EBO: ', num2str(EBO_calc(s0, lambdavec, Tvec))]);
disp(['Total Budget Spent: ', num2str(spent)]);


%{
budget
spent
objfunc
sn
while spent <= budget
    xn = min xn*cvec + EBO(sn) 
    spent = xn*cvec
    sn1 = sn + xn
end
%}

LRU1 = "to do"

% Question 8 should be answered in the report, and submitted below
% Enter on the format DynPtable = [ x0 EBO(x0) C(x0); x1 EB0(x1) C(x1); ... x4 EBO(x4) C(x4)]
% Where x0 to x4 are the row vectors with number of spare parts of each kind
% corresponding to the points optimal for budgets 0,100,150, 350, 500.
DynPtable = "to do"

% Question 9 should be answered in the report

% Question 10 should be answered in the report, and submitted below
NumberOfConfigurations = "to do"



function [p,R,EBO] = EBOcomp(lambda,T, smax)
    lamT = lambda*T;
    p(1) = exp(-lamT);
    R(1) = 1 - p(1);
    EBO(1) = lamT;
    for s=1:smax
        s1=s+1;
        p(s1) = lamT*p(s)/s;
        R(s1) = R(s) - p(s1);
        EBO(s1) = EBO(s) - R(s);
    end
end

function [cost] = costcomp(c, s)
    cost = c*s;
end

function [r, c] = indexMax(table)
    [M,I] = max(table,[],"all","linear");
    [r,c] = ind2sub(size(table), I);
end

function [EBO] = EBO_calc(S, lambdavec, Tvec)
    EBO = 0;
    for i = 1:size(S,2)
        [~,~, EBO_part] = EBOcomp(lambdavec(i),Tvec(i), S(i));
        EBO = EBO + EBO_part(end);
    end
end